\newcommand{\implementierungsphaseText}{
	% Gibt es nicht
}

\newcommand{\implementierungblazorpageText}{
	Es wurde mit der Implementierung der Blazor-Page begonnen, welche bei der Planung entworfen wurde. Dazu gehört das erstellen einer .razor-Datei im Projekt (siehe Anhang A3 in Abbildung 2), wobei eine Klasse mit dem Namen der Datei entsteht. In diesen Dateien können wir nicht nur den C\# Code abbilden sondern auch die für Blazor typischen Komponenten, mit denen das Frontend bearbeitet wird. Für unsere Applikation haben wir uns dazu entschieden, eine Komponente für die verschiedenen zu implementierenden Listenabschnitte erstellen (siehe Anhang A4, Abbildung 3). Für die Listeneinträge haben wir eine eigene Komponente angelegt, welche wir dann mit einem Button, in der Liste mit dem Titel "Open", über den Aufruf des asynchronen Tasks \colorbox{lightgray}{NewToDoItem} zuerst konfigurieren können und abschließend der To-Do Liste hinzufügen können.
}

\newcommand{\implementierungtodolisteText}{
	Für die einzelnen Listenabschnitte, in welchen die ToDoItems abgebildet werden, haben wir uns der Komponentenbibliothek Blazor.Radzen (ff. Radzen) bedient. Mit der Komponente \colorbox{lightgray}{RadzenDropZone} können wir bereiche definieren, in denen wir mit Drag-and-Drop später die Listeneinträge ablegen können (siehe Anhang A5, Abbildung 4). Als Parameter wird ein \colorbox{lightgray}{Value} mit dem Datentyp \colorbox{lightgray}{enum} erwartet, über den wir dem eigentlichen Item automatisch mitteilen, in welchem Zustand es sich befindet. Über die allgemeine Komponente \colorbox{lightgray}{ChildContet} definieren wir Zusätzliche Inhalte, welche wir in der Live-Ansicht rendern möchten. Für die Dropzonen sind dies die Titel. Diese fügen wir mit einer weiteren Radzen-Komponente, \colorbox{lightgray}{RadzenText} ein. Für die erste Spalte benutzen wir zusätlich eine \colorbox{lightgray}{Footer-Komponente}, in welchem sich der \colorbox{lightgray}{RadzenButton} befindet, um ein neues Item in die Liste einzufügen. Nachdem wir die anderen Dropzonen definiert haben, werden diese von einem \colorbox{lightgray}{RadzenDropZoneContainer} umschlossen. Als Pflicht-Parameter geben wir zuerst ein Typen des Objektes an, mit welchem später gearbeitet werden soll. In unserem Fall ist es unsere eigene Klasse \colorbox{lightgray}{ToDoItem}. Für den Parameter \colorbox{lightgray}{Data} haben wir im Code-Block dieser Seite eine generische Liste mit dem Typenparameter T (\colorbox{lightgray}{IList<T>}) verwendet und dieser den Namen 'data' und als Typ unsere Klasse \colorbox{lightgray}{ToDoItem} angegeben (siehe Anhang A6, Abbildung 5). Als nächstes brauchen wir einen \colorbox{lightgray}{ItemSelector}. Für diesen haben wir im Code-Block einen Delegaten mit dem Namen \colorbox{lightgray}{ItemSelector} erstellt. Dieser stellt eine vordefinierte Methode dar, welche zwei Parameter (T1 und T2) erwartet und einen Typ 'TResult' zurück gibt. In unserem Fall sind das \colorbox{lightgray}{T1 = ToDoItem}, \colorbox{lightgray}{T2 = RadzenDropZone<ToDoItem>} und \colorbox{lightgray}{TResult = bool}. Danach führen wir eine Lambda-Funktion aus, mit der Parameterliste \colorbox{lightgray}{(item, zone)}. In der Lambda-Funktion überprüfen wir schießlich ob der \colorbox{lightgray}{item.Status} gleich mit dem Status von \colorbox{lightgray}{zone.Value} ist und gleichzeitig ob \colorbox{lightgray}{item.Status} ungleich dem Status \colorbox{lightgray}{Status.Deleted} ist. Sind beide bedingungen erfüllt, gibt diese Funktion 'true' zurück, andernfalls 'false'. \neuerAbsatz Als nächstes übergeben wir den Parameter \colorbox{lightgray}{ItemRender} unsere Methode \colorbox{lightgray}{OnItemRender} welche als Argument den Typ \colorbox{lightgray}{RadzenDropZoneItemRenderEventArgs<ToDoItem>} erwartet. Im Methodenkörper implementieren wir, dass wir Items, welche den Status\\ \colorbox{lightgray}{Status.Deleted} haben, nicht länger gerendert werden, indem wir den Wert \colorbox{lightgray}{args.Value} das Ergebnis des vergleiches zwischen \colorbox{lightgray}{args.Item.Status} ist ungleich \colorbox{lightgray}{Status.Deleted} geben. Für den Parameter \colorbox{lightgray}{CanDrop} haben wir wie schon für den \colorbox{lightgray}{ItemSelector} einen gleichnamigen Delegate mit einer Lambda-Funktion erstellt. In diesem legen wir fest, dass die Items von ihrer Dropzone nur in die nächste oder vorherige bzw. in die "Delete"-Zone abgelegt werden können. \colorbox{lightgray}{Drop} ist der letzte wichtige Parameter für die\\ \colorbox{lightgray}{RadzenDropZoneContainer-Komponente}. Hier übergeben wir den asynchronen Task\\ \colorbox{lightgray}{OnDrop}. In diesem Task überprüfen wir die aktuelle Zone des Items und die Zone in welcher versucht wird, das Item wieder abzulegen.
}

\newcommand{\implementierungtodoitemText}{
	Für die Klasse \colorbox{lightgray}{ToDoItem} müssen wir, durch die besonderheit der Komponenten der Radzen Bibliothek, benötigen wir keinen Ausführbaren Code (siehe Anhang A7, Abbildung 6). Wir definieren eigene Parameter, welche wir benutzen um die Daten abzulegen und von wo aus diese wieder aufgerufen werden können. Der erste und wichtigste Parameter ist der \colorbox{lightgray}{enum Status} welchen wir gleich benennen. Dieser legt fest, in welchem Zustand sich das Item später befinden wird und ob es noch gerendert werden muss. Der nächste Parameter ist \colorbox{lightgray}{Title} von Typ \colorbox{lightgray}{string?}. Das '?' am ende des Typs gibt uns an, dass dieser Parameter auch \colorbox{lightgray}{null} sein darf. \colorbox{lightgray}{Id} vom Typ \colorbox{lightgray}{int} ist eine Vorbereitung um das Item später in eine Datenbank schreiben zu können. \colorbox{lightgray}{[DatabaseGereated(DatabaseGeneratedOption.Identity)]} wird im nächsten Abschnitt erklärt.\\Desweiteren haben wir uns für die Parameter \colorbox{lightgray}{CreationDate, DueDate, Category, Owner} sowie \colorbox{lightgray}{Description} entschlossen. \colorbox{lightgray}{CreationDate}(Datum der Erstellung) und \colorbox{lightgray}{DueDate}\\(Datum zu wann dieses To-Do abgeschlossen werden soll) sind von dem Typ \\\colorbox{lightgray}{DateTime}, die restlichen vom Typ \colorbox{lightgray}{string?}. Zum Schluss definieren wir noch einen leeren \colorbox{lightgray}{Konstruktor} der Klasse, welcher von Blazor gefordert ist, um die Klasse bei bedarf zu initialisieren.
}

\newcommand{\implementierungdatenbankanbindungText}{
	Da der Fokus dieses Projektes auf der Planung und Umsetzung einer Anwendung ist und Datenbanken in einem früheren Projekt bereits ausführlich behandelt wurde, haben wir uns dazu entschlossen die integrierte Funktion von Visual Studio zu nutzen und lassen eine MS SQL Datenbank automatisch generieren. Als erstes erstellten wir die \colorbox{lightgray}{ApplicationDbContext.cs}-Klasse, welche von der Klasse \colorbox{lightgray}{DbContext} aus dem Namespace \colorbox{lightgray}{Microsoft.EntityFrameworkCore} (siehe Anhang 10, Abbildung 9). In dieser Klasse definieren wir, welche Tabellen für uns erstellt werden sollen. Dazu nutzen wir die Klasse \colorbox{lightgray}{DbSet<T>}, wobei \colorbox{lightgray}{T} eine unserer gewünschten Klassen ist, zum Beispiel \colorbox{lightgray}{ToDoItem}, gefolgt von dem Namen den die Tabelle bekommen soll sowie \colorbox{lightgray}{Getter} und \colorbox{lightgray}{Setter}.\\Danach öffnen wir die \colorbox{lightgray}{Pakte-Manager-Konsole} und geben den Befehl \colorbox{lightgray}{"Add-Migration init"} ein. Dieser Befehl erstellt nun auf Basis der Parameter der Klassen, die wir als \colorbox{lightgray}{DbSet<T>} definiert haben, zwei neue Klassen an und legt diese im Ordner mit dem Namen \colorbox{lightgray}{Migration} (siehe Anhang A8, Abbildung 7) ab.\\Geben wir in der Konsole nun den Befehl \colorbox{lightgray}{"Update-Database"} ein und bestätigen die Eingabe, wird im Hintergrund eine MS SQL Datenbank auf dem Hostsystem erstellt und veröffentlicht. Mit dem in Visual Studio integrierten \\\colorbox{lightgray}{SQL Server-Objekt-Explorer} können wir den Aufbau der Datenbank kontrollieren und sehen dass wir 3 Tabellen haben, für unsere Klassen \colorbox{lightgray}{ToDoItem}, \colorbox{lightgray}{ToDoList} und \colorbox{lightgray}{Userclass} erstellt wurden. In der \colorbox{lightgray}{appsettings.json}-Datei müssen wir nur noch den \colorbox{lightgray}{DbConnectionString} angeben und in der Datei \colorbox{lightgray}{Startup.cs} eine neue Methode vom Typ \colorbox{lightgray}{void}, dem Namen \colorbox{lightgray}{ConfigureServices} und den Agrument \colorbox{lightgray}{services} mit dem Typ \colorbox{lightgray}{IServiceCollection} erstellen. Dort führen wir von der ServiceCollection die integrierte Methode\\\colorbox{lightgray}{AddDbContext<ApplicationDbContext>} mit einem Lambda-Aufruf aus, mit dem der zuvor definierte \colorbox{lightgray}{ConnectionString} angegeben wird (Anhang A9, Abbildung 8).
}